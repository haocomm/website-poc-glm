{"file":"index-0vvINzLF.js","mappings":"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","names":["_getIcon","_loadIcon","Iconify"],"sources":["../../../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/icon/defaults.mjs","../../../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/svg/html.mjs","../../../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/svg/size.mjs","../../../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/svg/url.mjs","../../../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/icon/square.mjs","../../../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/customisations/defaults.mjs","../../../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/svg/defs.mjs","../../../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/svg/build.mjs","../../../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/css/common.mjs","../../../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/css/format.mjs","../../../../node_modules/.pnpm/@iconify+utils@2.3.0/node_modules/@iconify/utils/lib/css/icon.mjs","../../../../node_modules/.pnpm/@nuxt+icon@1.15.0_magicast@0.5.0_vite@7.1.12_@types+node@20.19.24_jiti@2.6.1_terser@5.4_c88f73fdd9b09fc6d0cf16b755d83548/node_modules/@nuxt/icon/dist/runtime/components/shared.js","../../../../node_modules/.pnpm/@nuxt+icon@1.15.0_magicast@0.5.0_vite@7.1.12_@types+node@20.19.24_jiti@2.6.1_terser@5.4_c88f73fdd9b09fc6d0cf16b755d83548/node_modules/@nuxt/icon/dist/runtime/components/css.js","../../../../node_modules/.pnpm/nuxt@3.20.0_@parcel+watcher@2.5.1_@types+node@20.19.24_@vue+compiler-sfc@3.5.22_db0@0.3_fd67c23c8bf138543986fe37ecb217e6/node_modules/nuxt/dist/app/composables/asyncData.js","../../../../node_modules/.pnpm/@nuxt+icon@1.15.0_magicast@0.5.0_vite@7.1.12_@types+node@20.19.24_jiti@2.6.1_terser@5.4_c88f73fdd9b09fc6d0cf16b755d83548/node_modules/@nuxt/icon/dist/runtime/components/svg.js","../../../../node_modules/.pnpm/@nuxt+icon@1.15.0_magicast@0.5.0_vite@7.1.12_@types+node@20.19.24_jiti@2.6.1_terser@5.4_c88f73fdd9b09fc6d0cf16b755d83548/node_modules/@nuxt/icon/dist/runtime/components/index.js"],"sourcesContent":["const defaultIconDimensions = Object.freeze(\n  {\n    left: 0,\n    top: 0,\n    width: 16,\n    height: 16\n  }\n);\nconst defaultIconTransformations = Object.freeze({\n  rotate: 0,\n  vFlip: false,\n  hFlip: false\n});\nconst defaultIconProps = Object.freeze({\n  ...defaultIconDimensions,\n  ...defaultIconTransformations\n});\nconst defaultExtendedIconProps = Object.freeze({\n  ...defaultIconProps,\n  body: \"\",\n  hidden: false\n});\n\nexport { defaultExtendedIconProps, defaultIconDimensions, defaultIconProps, defaultIconTransformations };\n","function iconToHTML(body, attributes) {\n  let renderAttribsHTML = body.indexOf(\"xlink:\") === -1 ? \"\" : ' xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n  for (const attr in attributes) {\n    renderAttribsHTML += \" \" + attr + '=\"' + attributes[attr] + '\"';\n  }\n  return '<svg xmlns=\"http://www.w3.org/2000/svg\"' + renderAttribsHTML + \">\" + body + \"</svg>\";\n}\n\nexport { iconToHTML };\n","const unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;\nconst unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;\nfunction calculateSize(size, ratio, precision) {\n  if (ratio === 1) {\n    return size;\n  }\n  precision = precision || 100;\n  if (typeof size === \"number\") {\n    return Math.ceil(size * ratio * precision) / precision;\n  }\n  if (typeof size !== \"string\") {\n    return size;\n  }\n  const oldParts = size.split(unitsSplit);\n  if (oldParts === null || !oldParts.length) {\n    return size;\n  }\n  const newParts = [];\n  let code = oldParts.shift();\n  let isNumber = unitsTest.test(code);\n  while (true) {\n    if (isNumber) {\n      const num = parseFloat(code);\n      if (isNaN(num)) {\n        newParts.push(code);\n      } else {\n        newParts.push(Math.ceil(num * ratio * precision) / precision);\n      }\n    } else {\n      newParts.push(code);\n    }\n    code = oldParts.shift();\n    if (code === void 0) {\n      return newParts.join(\"\");\n    }\n    isNumber = !isNumber;\n  }\n}\n\nexport { calculateSize };\n","function encodeSVGforURL(svg) {\n  return svg.replace(/\"/g, \"'\").replace(/%/g, \"%25\").replace(/#/g, \"%23\").replace(/</g, \"%3C\").replace(/>/g, \"%3E\").replace(/\\s+/g, \" \");\n}\nfunction svgToData(svg) {\n  return \"data:image/svg+xml,\" + encodeSVGforURL(svg);\n}\nfunction svgToURL(svg) {\n  return 'url(\"' + svgToData(svg) + '\")';\n}\n\nexport { encodeSVGforURL, svgToData, svgToURL };\n","function makeIconSquare(icon) {\n  if (icon.width !== icon.height) {\n    const max = Math.max(icon.width, icon.height);\n    return {\n      ...icon,\n      width: max,\n      height: max,\n      left: icon.left - (max - icon.width) / 2,\n      top: icon.top - (max - icon.height) / 2\n    };\n  }\n  return icon;\n}\nfunction makeViewBoxSquare(viewBox) {\n  const [left, top, width, height] = viewBox;\n  if (width !== height) {\n    const max = Math.max(width, height);\n    return [left - (max - width) / 2, top - (max - height) / 2, max, max];\n  }\n  return viewBox;\n}\n\nexport { makeIconSquare, makeViewBoxSquare };\n","import { defaultIconTransformations } from '../icon/defaults.mjs';\n\nconst defaultIconSizeCustomisations = Object.freeze({\n  width: null,\n  height: null\n});\nconst defaultIconCustomisations = Object.freeze({\n  // Dimensions\n  ...defaultIconSizeCustomisations,\n  // Transformations\n  ...defaultIconTransformations\n});\n\nexport { defaultIconCustomisations, defaultIconSizeCustomisations };\n","function splitSVGDefs(content, tag = \"defs\") {\n  let defs = \"\";\n  const index = content.indexOf(\"<\" + tag);\n  while (index >= 0) {\n    const start = content.indexOf(\">\", index);\n    const end = content.indexOf(\"</\" + tag);\n    if (start === -1 || end === -1) {\n      break;\n    }\n    const endEnd = content.indexOf(\">\", end);\n    if (endEnd === -1) {\n      break;\n    }\n    defs += content.slice(start + 1, end).trim();\n    content = content.slice(0, index).trim() + content.slice(endEnd + 1);\n  }\n  return {\n    defs,\n    content\n  };\n}\nfunction mergeDefsAndContent(defs, content) {\n  return defs ? \"<defs>\" + defs + \"</defs>\" + content : content;\n}\nfunction wrapSVGContent(body, start, end) {\n  const split = splitSVGDefs(body);\n  return mergeDefsAndContent(split.defs, start + split.content + end);\n}\n\nexport { mergeDefsAndContent, splitSVGDefs, wrapSVGContent };\n","import { defaultIconProps } from '../icon/defaults.mjs';\nimport { defaultIconCustomisations } from '../customisations/defaults.mjs';\nimport { calculateSize } from './size.mjs';\nimport { wrapSVGContent } from './defs.mjs';\n\nconst isUnsetKeyword = (value) => value === \"unset\" || value === \"undefined\" || value === \"none\";\nfunction iconToSVG(icon, customisations) {\n  const fullIcon = {\n    ...defaultIconProps,\n    ...icon\n  };\n  const fullCustomisations = {\n    ...defaultIconCustomisations,\n    ...customisations\n  };\n  const box = {\n    left: fullIcon.left,\n    top: fullIcon.top,\n    width: fullIcon.width,\n    height: fullIcon.height\n  };\n  let body = fullIcon.body;\n  [fullIcon, fullCustomisations].forEach((props) => {\n    const transformations = [];\n    const hFlip = props.hFlip;\n    const vFlip = props.vFlip;\n    let rotation = props.rotate;\n    if (hFlip) {\n      if (vFlip) {\n        rotation += 2;\n      } else {\n        transformations.push(\n          \"translate(\" + (box.width + box.left).toString() + \" \" + (0 - box.top).toString() + \")\"\n        );\n        transformations.push(\"scale(-1 1)\");\n        box.top = box.left = 0;\n      }\n    } else if (vFlip) {\n      transformations.push(\n        \"translate(\" + (0 - box.left).toString() + \" \" + (box.height + box.top).toString() + \")\"\n      );\n      transformations.push(\"scale(1 -1)\");\n      box.top = box.left = 0;\n    }\n    let tempValue;\n    if (rotation < 0) {\n      rotation -= Math.floor(rotation / 4) * 4;\n    }\n    rotation = rotation % 4;\n    switch (rotation) {\n      case 1:\n        tempValue = box.height / 2 + box.top;\n        transformations.unshift(\n          \"rotate(90 \" + tempValue.toString() + \" \" + tempValue.toString() + \")\"\n        );\n        break;\n      case 2:\n        transformations.unshift(\n          \"rotate(180 \" + (box.width / 2 + box.left).toString() + \" \" + (box.height / 2 + box.top).toString() + \")\"\n        );\n        break;\n      case 3:\n        tempValue = box.width / 2 + box.left;\n        transformations.unshift(\n          \"rotate(-90 \" + tempValue.toString() + \" \" + tempValue.toString() + \")\"\n        );\n        break;\n    }\n    if (rotation % 2 === 1) {\n      if (box.left !== box.top) {\n        tempValue = box.left;\n        box.left = box.top;\n        box.top = tempValue;\n      }\n      if (box.width !== box.height) {\n        tempValue = box.width;\n        box.width = box.height;\n        box.height = tempValue;\n      }\n    }\n    if (transformations.length) {\n      body = wrapSVGContent(\n        body,\n        '<g transform=\"' + transformations.join(\" \") + '\">',\n        \"</g>\"\n      );\n    }\n  });\n  const customisationsWidth = fullCustomisations.width;\n  const customisationsHeight = fullCustomisations.height;\n  const boxWidth = box.width;\n  const boxHeight = box.height;\n  let width;\n  let height;\n  if (customisationsWidth === null) {\n    height = customisationsHeight === null ? \"1em\" : customisationsHeight === \"auto\" ? boxHeight : customisationsHeight;\n    width = calculateSize(height, boxWidth / boxHeight);\n  } else {\n    width = customisationsWidth === \"auto\" ? boxWidth : customisationsWidth;\n    height = customisationsHeight === null ? calculateSize(width, boxHeight / boxWidth) : customisationsHeight === \"auto\" ? boxHeight : customisationsHeight;\n  }\n  const attributes = {};\n  const setAttr = (prop, value) => {\n    if (!isUnsetKeyword(value)) {\n      attributes[prop] = value.toString();\n    }\n  };\n  setAttr(\"width\", width);\n  setAttr(\"height\", height);\n  const viewBox = [box.left, box.top, boxWidth, boxHeight];\n  attributes.viewBox = viewBox.join(\" \");\n  return {\n    attributes,\n    viewBox,\n    body\n  };\n}\n\nexport { iconToSVG, isUnsetKeyword };\n","import { iconToHTML } from '../svg/html.mjs';\nimport { calculateSize } from '../svg/size.mjs';\nimport { svgToURL } from '../svg/url.mjs';\nimport { makeViewBoxSquare } from '../icon/square.mjs';\nimport { iconToSVG } from '../svg/build.mjs';\nimport '../icon/defaults.mjs';\nimport '../customisations/defaults.mjs';\nimport '../svg/defs.mjs';\n\nfunction getCommonCSSRules(options) {\n  const result = {\n    display: \"inline-block\",\n    width: \"1em\",\n    height: \"1em\"\n  };\n  const varName = options.varName;\n  if (options.pseudoSelector) {\n    result[\"content\"] = \"''\";\n  }\n  switch (options.mode) {\n    case \"background\":\n      if (varName) {\n        result[\"background-image\"] = \"var(--\" + varName + \")\";\n      }\n      result[\"background-repeat\"] = \"no-repeat\";\n      result[\"background-size\"] = \"100% 100%\";\n      break;\n    case \"mask\":\n      result[\"background-color\"] = \"currentColor\";\n      if (varName) {\n        result[\"mask-image\"] = result[\"-webkit-mask-image\"] = \"var(--\" + varName + \")\";\n      }\n      result[\"mask-repeat\"] = result[\"-webkit-mask-repeat\"] = \"no-repeat\";\n      result[\"mask-size\"] = result[\"-webkit-mask-size\"] = \"100% 100%\";\n      break;\n  }\n  return result;\n}\nfunction generateItemCSSRules(icon, options) {\n  const result = {};\n  const varName = options.varName;\n  const buildResult = iconToSVG(icon);\n  let viewBox = buildResult.viewBox;\n  if (viewBox[2] !== viewBox[3]) {\n    if (options.forceSquare) {\n      viewBox = makeViewBoxSquare(viewBox);\n    } else {\n      result[\"width\"] = calculateSize(\"1em\", viewBox[2] / viewBox[3]);\n    }\n  }\n  const svg = iconToHTML(\n    buildResult.body.replace(/currentColor/g, options.color || \"black\"),\n    {\n      viewBox: `${viewBox[0]} ${viewBox[1]} ${viewBox[2]} ${viewBox[3]}`,\n      width: `${viewBox[2]}`,\n      height: `${viewBox[3]}`\n    }\n  );\n  const url = svgToURL(svg);\n  if (varName) {\n    result[\"--\" + varName] = url;\n  } else {\n    switch (options.mode) {\n      case \"background\":\n        result[\"background-image\"] = url;\n        break;\n      case \"mask\":\n        result[\"mask-image\"] = result[\"-webkit-mask-image\"] = url;\n        break;\n    }\n  }\n  return result;\n}\nfunction generateItemContent(icon, options) {\n  const buildResult = iconToSVG(icon);\n  const viewBox = buildResult.viewBox;\n  const height = options.height;\n  const width = options.width ?? calculateSize(height, viewBox[2] / viewBox[3]);\n  const svg = iconToHTML(\n    buildResult.body.replace(/currentColor/g, options.color || \"black\"),\n    {\n      viewBox: `${viewBox[0]} ${viewBox[1]} ${viewBox[2]} ${viewBox[3]}`,\n      width: width.toString(),\n      height: height.toString()\n    }\n  );\n  return svgToURL(svg);\n}\n\nexport { generateItemCSSRules, generateItemContent, getCommonCSSRules };\n","const format = {\n  selectorStart: {\n    compressed: \"{\",\n    compact: \" {\",\n    expanded: \" {\"\n  },\n  selectorEnd: {\n    compressed: \"}\",\n    compact: \"; }\\n\",\n    expanded: \";\\n}\\n\"\n  },\n  rule: {\n    compressed: \"{key}:\",\n    compact: \" {key}: \",\n    expanded: \"\\n  {key}: \"\n  }\n};\nfunction formatCSS(data, mode = \"expanded\") {\n  const results = [];\n  for (let i = 0; i < data.length; i++) {\n    const { selector, rules } = data[i];\n    const fullSelector = selector instanceof Array ? selector.join(mode === \"compressed\" ? \",\" : \", \") : selector;\n    let entry = fullSelector + format.selectorStart[mode];\n    let firstRule = true;\n    for (const key in rules) {\n      if (!firstRule) {\n        entry += \";\";\n      }\n      entry += format.rule[mode].replace(\"{key}\", key) + rules[key];\n      firstRule = false;\n    }\n    entry += format.selectorEnd[mode];\n    results.push(entry);\n  }\n  return results.join(mode === \"compressed\" ? \"\" : \"\\n\");\n}\n\nexport { formatCSS };\n","import { defaultIconProps } from '../icon/defaults.mjs';\nimport { getCommonCSSRules, generateItemCSSRules, generateItemContent } from './common.mjs';\nimport { formatCSS } from './format.mjs';\nimport '../svg/html.mjs';\nimport '../svg/size.mjs';\nimport '../svg/url.mjs';\nimport '../icon/square.mjs';\nimport '../svg/build.mjs';\nimport '../customisations/defaults.mjs';\nimport '../svg/defs.mjs';\n\nfunction getIconCSS(icon, options = {}) {\n  const body = options.customise ? options.customise(icon.body) : icon.body;\n  const mode = options.mode || (options.color || !body.includes(\"currentColor\") ? \"background\" : \"mask\");\n  let varName = options.varName;\n  if (varName === void 0 && mode === \"mask\") {\n    varName = \"svg\";\n  }\n  const newOptions = {\n    ...options,\n    // Override mode and varName\n    mode,\n    varName\n  };\n  if (mode === \"background\") {\n    delete newOptions.varName;\n  }\n  const rules = {\n    ...options.rules,\n    ...getCommonCSSRules(newOptions),\n    ...generateItemCSSRules(\n      {\n        ...defaultIconProps,\n        ...icon,\n        body\n      },\n      newOptions\n    )\n  };\n  const selector = options.iconSelector || \".icon\";\n  return formatCSS(\n    [\n      {\n        selector,\n        rules\n      }\n    ],\n    newOptions.format\n  );\n}\nfunction getIconContentCSS(icon, options) {\n  const body = options.customise ? options.customise(icon.body) : icon.body;\n  const content = generateItemContent(\n    {\n      ...defaultIconProps,\n      ...icon,\n      body\n    },\n    options\n  );\n  const selector = options.iconSelector || \".icon::after\";\n  return formatCSS(\n    [\n      {\n        selector,\n        rules: {\n          ...options.rules,\n          content\n        }\n      }\n    ],\n    options.format\n  );\n}\n\nexport { getIconCSS, getIconContentCSS };\n","import { computed } from \"vue\";\nimport { getIcon as _getIcon, addIcon as _addIcon, loadIcon as _loadIcon } from \"@iconify/vue\";\nimport { useAppConfig } from \"#imports\";\nimport { init as initClientBundle } from \"#build/nuxt-icon-client-bundle\";\nexport { initClientBundle };\nexport async function loadIcon(name, timeout) {\n  if (!name)\n    return null;\n  initClientBundle(_addIcon);\n  const _icon = _getIcon(name);\n  if (_icon)\n    return _icon;\n  let timeoutWarn;\n  const load = _loadIcon(name).catch(() => {\n    console.warn(`[Icon] failed to load icon \\`${name}\\``);\n    return null;\n  });\n  if (timeout > 0)\n    await Promise.race([\n      load,\n      new Promise((resolve) => {\n        timeoutWarn = setTimeout(() => {\n          console.warn(`[Icon] loading icon \\`${name}\\` timed out after ${timeout}ms`);\n          resolve();\n        }, timeout);\n      })\n    ]).finally(() => clearTimeout(timeoutWarn));\n  else\n    await load;\n  return _getIcon(name);\n}\nexport function useResolvedName(getName) {\n  const options = useAppConfig().icon;\n  const collections = (options.collections || []).sort((a, b) => b.length - a.length);\n  return computed(() => {\n    const name = getName();\n    const bare = name.startsWith(options.cssSelectorPrefix) ? name.slice(options.cssSelectorPrefix.length) : name;\n    const resolved = options.aliases?.[bare] || bare;\n    if (!resolved.includes(\":\")) {\n      const collection = collections.find((c) => resolved.startsWith(c + \"-\"));\n      return collection ? collection + \":\" + resolved.slice(collection.length + 1) : resolved;\n    }\n    return resolved;\n  });\n}\nexport function resolveCustomizeFn(customize, globalCustomize) {\n  if (customize === false) return void 0;\n  if (customize === true || customize === null) return globalCustomize;\n  return customize;\n}\n","import { addIcon, getIcon as _getIcon } from \"@iconify/vue\";\nimport { computed, watch, h, defineComponent } from \"vue\";\nimport { getIconCSS } from \"@iconify/utils/lib/css/icon\";\nimport { loadIcon, resolveCustomizeFn } from \"./shared.js\";\nimport { useAppConfig, useNuxtApp, useHead, useRuntimeConfig, onServerPrefetch } from \"#imports\";\nlet cssSelectors;\nconst SYMBOL_SERVER_CSS = \"NUXT_ICONS_SERVER_CSS\";\nfunction escapeCssSelector(selector) {\n  return selector.replace(/([^\\w-])/g, \"\\\\$1\");\n}\nfunction getAllSelectors() {\n  if (cssSelectors)\n    return cssSelectors;\n  cssSelectors = /* @__PURE__ */ new Set();\n  const filter = (selector) => {\n    selector = selector.replace(/^:where\\((.*)\\)$/, \"$1\").trim();\n    if (selector.startsWith(\".\")) {\n      return selector;\n    }\n  };\n  const scanCssRules = (rules) => {\n    if (!rules?.length)\n      return;\n    for (const rule of rules) {\n      if (rule?.cssRules) {\n        scanCssRules(rule.cssRules);\n      }\n      const selectorRaw = rule?.selectorText;\n      if (typeof selectorRaw === \"string\") {\n        const selector = filter(selectorRaw);\n        if (selector)\n          cssSelectors.add(selector);\n      }\n    }\n  };\n  if (typeof document !== \"undefined\") {\n    for (const styleSheet of document.styleSheets) {\n      try {\n        const rules = styleSheet.cssRules || styleSheet.rules;\n        scanCssRules(rules);\n      } catch {\n      }\n    }\n  }\n  return cssSelectors;\n}\nexport const NuxtIconCss = /* @__PURE__ */ defineComponent({\n  name: \"NuxtIconCss\",\n  props: {\n    name: {\n      type: String,\n      required: true\n    },\n    customize: {\n      type: [Function, Boolean, null],\n      default: null,\n      required: false\n    }\n  },\n  setup(props) {\n    const nuxt = useNuxtApp();\n    const options = useAppConfig().icon;\n    const cssClass = computed(() => props.name ? options.cssSelectorPrefix + props.name : \"\");\n    function getIcon(name) {\n      if (!name)\n        return;\n      const icon = _getIcon(name);\n      if (icon)\n        return icon;\n      const payload = nuxt.payload?.data?.[name];\n      if (payload) {\n        addIcon(name, payload);\n        return payload;\n      }\n    }\n    const selector = computed(() => \".\" + escapeCssSelector(cssClass.value));\n    function getCSS(icon, withLayer = true) {\n      let iconSelector = selector.value;\n      if (options.cssWherePseudo) {\n        iconSelector = `:where(${iconSelector})`;\n      }\n      const css = getIconCSS(icon, {\n        iconSelector,\n        format: \"compressed\",\n        customise: resolveCustomizeFn(props.customize, options.customize)\n      });\n      if (options.cssLayer && withLayer) {\n        return `@layer ${options.cssLayer} { ${css} }`;\n      }\n      return css;\n    }\n    if (import.meta.client) {\n      const selectors = getAllSelectors();\n      async function mountCSS(icon) {\n        if (selectors.has(selector.value))\n          return;\n        if (typeof document === \"undefined\")\n          return;\n        const style = document.createElement(\"style\");\n        style.textContent = getCSS(icon);\n        if (import.meta.dev) {\n          style.dataset.nuxtIconDev = props.name;\n        }\n        const firstStyle = document.head.querySelector('style, link[rel=\"stylesheet\"]');\n        if (firstStyle)\n          document.head.insertBefore(style, firstStyle);\n        else\n          document.head.appendChild(style);\n        selectors.add(selector.value);\n      }\n      watch(\n        () => props.name,\n        () => {\n          if (selectors.has(selector.value)) {\n            return;\n          }\n          const data = getIcon(props.name);\n          if (data) {\n            mountCSS(data);\n          } else {\n            loadIcon(props.name, import.meta.server ? options.fetchTimeout : -1).then((data2) => {\n              if (data2)\n                mountCSS(data2);\n            }).catch(() => null);\n          }\n        },\n        { immediate: true }\n      );\n    }\n    onServerPrefetch(async () => {\n      if (import.meta.server) {\n        const configs = useRuntimeConfig().icon || {};\n        if (!configs?.serverKnownCssClasses?.includes(cssClass.value)) {\n          const icon = await loadIcon(props.name, options.fetchTimeout).catch(() => null);\n          if (!icon)\n            return null;\n          let ssrCSS = nuxt.vueApp._context.provides[SYMBOL_SERVER_CSS];\n          if (!ssrCSS) {\n            ssrCSS = nuxt.vueApp._context.provides[SYMBOL_SERVER_CSS] = /* @__PURE__ */ new Map();\n            nuxt.runWithContext(() => {\n              useHead({\n                style: [\n                  () => {\n                    const sep = import.meta.dev ? \"\\n\" : \"\";\n                    let css = Array.from(ssrCSS.values()).sort().join(sep);\n                    if (options.cssLayer) {\n                      css = `@layer ${options.cssLayer} {${sep}${css}${sep}}`;\n                    }\n                    return { innerHTML: css };\n                  }\n                ]\n              }, {\n                tagPriority: \"low\"\n              });\n            });\n          }\n          if (props.name && !ssrCSS.has(props.name)) {\n            const css = getCSS(icon, false);\n            ssrCSS.set(props.name, css);\n          }\n          return null;\n        }\n      }\n    });\n    return () => h(\"span\", { class: [\"iconify\", cssClass.value] });\n  }\n});\n","import { computed, getCurrentInstance, getCurrentScope, inject, isShallow, nextTick, onBeforeMount, onScopeDispose, onServerPrefetch, onUnmounted, queuePostFlushCb, ref, shallowRef, toRef, toValue, unref, watch } from \"vue\";\nimport { debounce } from \"perfect-debounce\";\nimport { hash } from \"ohash\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { getUserCaller, toArray } from \"../utils.js\";\nimport { clientOnlySymbol } from \"../components/client-only.js\";\nimport { createError } from \"./error.js\";\nimport { onNuxtReady } from \"./ready.js\";\nimport { asyncDataDefaults, granularCachedData, pendingWhenIdle, purgeCachedData, resetAsyncDataToUndefined } from \"#build/nuxt.config.mjs\";\nconst isDefer = (dedupe) => dedupe === \"defer\" || dedupe === false;\nexport function useAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (_isAutoKeyNeeded(args[0], args[1])) {\n    args.unshift(autoKey);\n  }\n  let [_key, _handler, options = {}] = args;\n  let keyChanging = false;\n  const key = computed(() => toValue(_key));\n  if (typeof key.value !== \"string\") {\n    throw new TypeError(\"[nuxt] [useAsyncData] key must be a string.\");\n  }\n  if (typeof _handler !== \"function\") {\n    throw new TypeError(\"[nuxt] [useAsyncData] handler must be a function.\");\n  }\n  const nuxtApp = useNuxtApp();\n  options.server ??= true;\n  options.default ??= getDefault;\n  options.getCachedData ??= getDefaultCachedData;\n  options.lazy ??= false;\n  options.immediate ??= true;\n  options.deep ??= asyncDataDefaults.deep;\n  options.dedupe ??= \"cancel\";\n  const functionName = options._functionName || \"useAsyncData\";\n  if (import.meta.dev && typeof options.dedupe === \"boolean\") {\n    console.warn(`[nuxt] \\`boolean\\` values are deprecated for the \\`dedupe\\` option of \\`${functionName}\\` and will be removed in the future. Use 'cancel' or 'defer' instead.`);\n  }\n  const currentData = nuxtApp._asyncData[key.value];\n  if (import.meta.dev && currentData) {\n    const warnings = [];\n    const values = createHash(_handler, options);\n    if (values.handler !== currentData._hash?.handler) {\n      warnings.push(`different handler`);\n    }\n    for (const opt of [\"transform\", \"pick\", \"getCachedData\"]) {\n      if (values[opt] !== currentData._hash[opt]) {\n        warnings.push(`different \\`${opt}\\` option`);\n      }\n    }\n    if (currentData._default.toString() !== options.default.toString()) {\n      warnings.push(`different \\`default\\` value`);\n    }\n    if (options.deep && isShallow(currentData.data)) {\n      warnings.push(`mismatching \\`deep\\` option`);\n    }\n    if (warnings.length) {\n      const caller = getUserCaller();\n      const explanation = caller ? ` (used at ${caller.source}:${caller.line}:${caller.column})` : \"\";\n      console.warn(`[nuxt] [${functionName}] Incompatible options detected for \"${key.value}\"${explanation}:\n${warnings.map((w) => `- ${w}`).join(\"\\n\")}\nYou can use a different key or move the call to a composable to ensure the options are shared across calls.`);\n    }\n  }\n  function createInitialFetch() {\n    const initialFetchOptions = { cause: \"initial\", dedupe: options.dedupe };\n    if (!nuxtApp._asyncData[key.value]?._init) {\n      initialFetchOptions.cachedData = options.getCachedData(key.value, nuxtApp, { cause: \"initial\" });\n      nuxtApp._asyncData[key.value] = createAsyncData(nuxtApp, key.value, _handler, options, initialFetchOptions.cachedData);\n    }\n    return () => nuxtApp._asyncData[key.value].execute(initialFetchOptions);\n  }\n  const initialFetch = createInitialFetch();\n  const asyncData = nuxtApp._asyncData[key.value];\n  asyncData._deps++;\n  const fetchOnServer = options.server !== false && nuxtApp.payload.serverRendered;\n  if (import.meta.server && fetchOnServer && options.immediate) {\n    const promise = initialFetch();\n    if (getCurrentInstance()) {\n      onServerPrefetch(() => promise);\n    } else {\n      nuxtApp.hook(\"app:created\", async () => {\n        await promise;\n      });\n    }\n  }\n  if (import.meta.client) {\n    let unregister = function(key2) {\n      const data = nuxtApp._asyncData[key2];\n      if (data?._deps) {\n        data._deps--;\n        if (data._deps === 0) {\n          data?._off();\n        }\n      }\n    };\n    const instance = getCurrentInstance();\n    if (instance && fetchOnServer && options.immediate && !instance.sp) {\n      instance.sp = [];\n    }\n    if (import.meta.dev && !nuxtApp.isHydrating && !nuxtApp._processingMiddleware && (!instance || instance?.isMounted)) {\n      console.warn(`[nuxt] [${functionName}] Component is already mounted, please use $fetch instead. See https://nuxt.com/docs/getting-started/data-fetching`);\n    }\n    if (instance && !instance._nuxtOnBeforeMountCbs) {\n      instance._nuxtOnBeforeMountCbs = [];\n      const cbs = instance._nuxtOnBeforeMountCbs;\n      onBeforeMount(() => {\n        cbs.forEach((cb) => {\n          cb();\n        });\n        cbs.splice(0, cbs.length);\n      });\n      onUnmounted(() => cbs.splice(0, cbs.length));\n    }\n    const isWithinClientOnly = instance && (instance._nuxtClientOnly || inject(clientOnlySymbol, false));\n    if (fetchOnServer && nuxtApp.isHydrating && (asyncData.error.value || asyncData.data.value != null)) {\n      if (pendingWhenIdle) {\n        asyncData.pending.value = false;\n      }\n      asyncData.status.value = asyncData.error.value ? \"error\" : \"success\";\n    } else if (instance && (!isWithinClientOnly && nuxtApp.payload.serverRendered && nuxtApp.isHydrating || options.lazy) && options.immediate) {\n      instance._nuxtOnBeforeMountCbs.push(initialFetch);\n    } else if (options.immediate) {\n      initialFetch();\n    }\n    const hasScope = getCurrentScope();\n    const unsubKeyWatcher = watch(key, (newKey, oldKey) => {\n      if ((newKey || oldKey) && newKey !== oldKey) {\n        keyChanging = true;\n        const hadData = nuxtApp._asyncData[oldKey]?.data.value !== asyncDataDefaults.value;\n        const wasRunning = nuxtApp._asyncDataPromises[oldKey] !== void 0;\n        const initialFetchOptions = { cause: \"initial\", dedupe: options.dedupe };\n        if (!nuxtApp._asyncData[newKey]?._init) {\n          let initialValue;\n          if (oldKey && hadData) {\n            initialValue = nuxtApp._asyncData[oldKey].data.value;\n          } else {\n            initialValue = options.getCachedData(newKey, nuxtApp, { cause: \"initial\" });\n            initialFetchOptions.cachedData = initialValue;\n          }\n          nuxtApp._asyncData[newKey] = createAsyncData(nuxtApp, newKey, _handler, options, initialValue);\n        }\n        nuxtApp._asyncData[newKey]._deps++;\n        if (oldKey) {\n          unregister(oldKey);\n        }\n        if (options.immediate || hadData || wasRunning) {\n          nuxtApp._asyncData[newKey].execute(initialFetchOptions);\n        }\n        queuePostFlushCb(() => {\n          keyChanging = false;\n        });\n      }\n    }, { flush: \"sync\" });\n    const unsubParamsWatcher = options.watch ? watch(options.watch, () => {\n      if (keyChanging) {\n        return;\n      }\n      asyncData._execute({ cause: \"watch\", dedupe: options.dedupe });\n    }) : () => {\n    };\n    if (hasScope) {\n      onScopeDispose(() => {\n        unsubKeyWatcher();\n        unsubParamsWatcher();\n        unregister(key.value);\n      });\n    }\n  }\n  const asyncReturn = {\n    data: writableComputedRef(() => nuxtApp._asyncData[key.value]?.data),\n    pending: writableComputedRef(() => nuxtApp._asyncData[key.value]?.pending),\n    status: writableComputedRef(() => nuxtApp._asyncData[key.value]?.status),\n    error: writableComputedRef(() => nuxtApp._asyncData[key.value]?.error),\n    refresh: (...args2) => {\n      if (!nuxtApp._asyncData[key.value]?._init) {\n        const initialFetch2 = createInitialFetch();\n        return initialFetch2();\n      }\n      return nuxtApp._asyncData[key.value].execute(...args2);\n    },\n    execute: (...args2) => asyncReturn.refresh(...args2),\n    clear: () => {\n      const entry = nuxtApp._asyncData[key.value];\n      if (entry?._abortController) {\n        try {\n          entry._abortController.abort(new DOMException(\"AsyncData aborted by user.\", \"AbortError\"));\n        } finally {\n          entry._abortController = void 0;\n        }\n      }\n      clearNuxtDataByKey(nuxtApp, key.value);\n    }\n  };\n  const asyncDataPromise = Promise.resolve(nuxtApp._asyncDataPromises[key.value]).then(() => asyncReturn);\n  Object.assign(asyncDataPromise, asyncReturn);\n  return asyncDataPromise;\n}\nfunction writableComputedRef(getter) {\n  return computed({\n    get() {\n      return getter()?.value;\n    },\n    set(value) {\n      const ref2 = getter();\n      if (ref2) {\n        ref2.value = value;\n      }\n    }\n  });\n}\nexport function useLazyAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (_isAutoKeyNeeded(args[0], args[1])) {\n    args.unshift(autoKey);\n  }\n  const [key, handler, options = {}] = args;\n  if (import.meta.dev) {\n    options._functionName ||= \"useLazyAsyncData\";\n  }\n  return useAsyncData(key, handler, { ...options, lazy: true }, null);\n}\nfunction _isAutoKeyNeeded(keyOrFetcher, fetcher) {\n  if (typeof keyOrFetcher === \"string\") {\n    return false;\n  }\n  if (typeof keyOrFetcher === \"object\" && keyOrFetcher !== null) {\n    return false;\n  }\n  if (typeof keyOrFetcher === \"function\" && typeof fetcher === \"function\") {\n    return false;\n  }\n  return true;\n}\nexport function useNuxtData(key) {\n  const nuxtApp = useNuxtApp();\n  if (!(key in nuxtApp.payload.data)) {\n    nuxtApp.payload.data[key] = asyncDataDefaults.value;\n  }\n  if (nuxtApp._asyncData[key]) {\n    const data = nuxtApp._asyncData[key];\n    data._deps++;\n    if (getCurrentScope()) {\n      onScopeDispose(() => {\n        data._deps--;\n        if (data._deps === 0) {\n          data?._off();\n        }\n      });\n    }\n  }\n  return {\n    data: computed({\n      get() {\n        return nuxtApp._asyncData[key]?.data.value ?? nuxtApp.payload.data[key];\n      },\n      set(value) {\n        if (nuxtApp._asyncData[key]) {\n          nuxtApp._asyncData[key].data.value = value;\n        } else {\n          nuxtApp.payload.data[key] = value;\n        }\n      }\n    })\n  };\n}\nexport async function refreshNuxtData(keys) {\n  if (import.meta.server) {\n    return Promise.resolve();\n  }\n  await new Promise((resolve) => onNuxtReady(resolve));\n  const _keys = keys ? toArray(keys) : void 0;\n  await useNuxtApp().hooks.callHookParallel(\"app:data:refresh\", _keys);\n}\nexport function clearNuxtData(keys) {\n  const nuxtApp = useNuxtApp();\n  const _allKeys = Object.keys(nuxtApp.payload.data);\n  const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : toArray(keys);\n  for (const key of _keys) {\n    clearNuxtDataByKey(nuxtApp, key);\n  }\n}\nfunction clearNuxtDataByKey(nuxtApp, key) {\n  if (key in nuxtApp.payload.data) {\n    nuxtApp.payload.data[key] = void 0;\n  }\n  if (key in nuxtApp.payload._errors) {\n    nuxtApp.payload._errors[key] = asyncDataDefaults.errorValue;\n  }\n  if (nuxtApp._asyncData[key]) {\n    nuxtApp._asyncData[key].data.value = resetAsyncDataToUndefined ? void 0 : unref(nuxtApp._asyncData[key]._default());\n    nuxtApp._asyncData[key].error.value = asyncDataDefaults.errorValue;\n    if (pendingWhenIdle) {\n      nuxtApp._asyncData[key].pending.value = false;\n    }\n    nuxtApp._asyncData[key].status.value = \"idle\";\n  }\n  if (key in nuxtApp._asyncDataPromises) {\n    nuxtApp._asyncDataPromises[key] = void 0;\n  }\n}\nfunction pick(obj, keys) {\n  const newObj = {};\n  for (const key of keys) {\n    newObj[key] = obj[key];\n  }\n  return newObj;\n}\nfunction createAsyncData(nuxtApp, key, _handler, options, initialCachedData) {\n  nuxtApp.payload._errors[key] ??= asyncDataDefaults.errorValue;\n  const hasCustomGetCachedData = options.getCachedData !== getDefaultCachedData;\n  const handler = import.meta.client || !import.meta.prerender || !nuxtApp.ssrContext?._sharedPrerenderCache ? _handler : (nuxtApp2, options2) => {\n    const value = nuxtApp2.ssrContext._sharedPrerenderCache.get(key);\n    if (value) {\n      return value;\n    }\n    const promise = Promise.resolve().then(() => nuxtApp2.runWithContext(() => _handler(nuxtApp2, options2)));\n    nuxtApp2.ssrContext._sharedPrerenderCache.set(key, promise);\n    return promise;\n  };\n  const _ref = options.deep ? ref : shallowRef;\n  const hasCachedData = initialCachedData != null;\n  const unsubRefreshAsyncData = nuxtApp.hook(\"app:data:refresh\", async (keys) => {\n    if (!keys || keys.includes(key)) {\n      await asyncData.execute({ cause: \"refresh:hook\" });\n    }\n  });\n  const asyncData = {\n    data: _ref(hasCachedData ? initialCachedData : options.default()),\n    pending: pendingWhenIdle ? shallowRef(!hasCachedData) : computed(() => asyncData.status.value === \"pending\"),\n    error: toRef(nuxtApp.payload._errors, key),\n    status: shallowRef(\"idle\"),\n    execute: (...args) => {\n      const [_opts, newValue = void 0] = args;\n      const opts = _opts && newValue === void 0 && typeof _opts === \"object\" ? _opts : {};\n      if (import.meta.dev && newValue !== void 0 && (!_opts || typeof _opts !== \"object\")) {\n        console.warn(`[nuxt] [${options._functionName}] Do not pass \\`execute\\` directly to \\`watch\\`. Instead, use an inline function, such as \\`watch(q, () => execute())\\`.`);\n      }\n      if (nuxtApp._asyncDataPromises[key]) {\n        if (isDefer(opts.dedupe ?? options.dedupe)) {\n          return nuxtApp._asyncDataPromises[key];\n        }\n      }\n      if (granularCachedData || opts.cause === \"initial\" || nuxtApp.isHydrating) {\n        const cachedData = \"cachedData\" in opts ? opts.cachedData : options.getCachedData(key, nuxtApp, { cause: opts.cause ?? \"refresh:manual\" });\n        if (cachedData != null) {\n          nuxtApp.payload.data[key] = asyncData.data.value = cachedData;\n          asyncData.error.value = asyncDataDefaults.errorValue;\n          asyncData.status.value = \"success\";\n          return Promise.resolve(cachedData);\n        }\n      }\n      if (pendingWhenIdle) {\n        asyncData.pending.value = true;\n      }\n      if (asyncData._abortController) {\n        asyncData._abortController.abort(new DOMException(\"AsyncData request cancelled by deduplication\", \"AbortError\"));\n      }\n      asyncData._abortController = new AbortController();\n      asyncData.status.value = \"pending\";\n      const promise = new Promise(\n        (resolve, reject) => {\n          try {\n            const timeout = opts.timeout ?? options.timeout;\n            const mergedSignal = mergeAbortSignals([asyncData._abortController?.signal, opts?.signal], timeout);\n            if (mergedSignal.aborted) {\n              const reason = mergedSignal.reason;\n              reject(reason instanceof Error ? reason : new DOMException(String(reason ?? \"Aborted\"), \"AbortError\"));\n              return;\n            }\n            mergedSignal.addEventListener(\"abort\", () => {\n              const reason = mergedSignal.reason;\n              reject(reason instanceof Error ? reason : new DOMException(String(reason ?? \"Aborted\"), \"AbortError\"));\n            }, { once: true });\n            return Promise.resolve(handler(nuxtApp, { signal: mergedSignal })).then(resolve, reject);\n          } catch (err) {\n            reject(err);\n          }\n        }\n      ).then(async (_result) => {\n        let result = _result;\n        if (options.transform) {\n          result = await options.transform(_result);\n        }\n        if (options.pick) {\n          result = pick(result, options.pick);\n        }\n        if (import.meta.dev && import.meta.server && result == null) {\n          const caller = getUserCaller();\n          const explanation = caller ? ` (used at ${caller.source}:${caller.line}:${caller.column})` : \"\";\n          console.warn(`[nuxt] \\`${options._functionName || \"useAsyncData\"}${explanation}\\` must return a value (it should not be \\`undefined\\` or \\`null\\`) or the request may be duplicated on the client side.`);\n        }\n        nuxtApp.payload.data[key] = result;\n        asyncData.data.value = result;\n        asyncData.error.value = asyncDataDefaults.errorValue;\n        asyncData.status.value = \"success\";\n      }).catch((error) => {\n        if (nuxtApp._asyncDataPromises[key] && nuxtApp._asyncDataPromises[key] !== promise) {\n          return;\n        }\n        if (asyncData._abortController?.signal.aborted) {\n          return;\n        }\n        if (typeof DOMException !== \"undefined\" && error instanceof DOMException && error.name === \"AbortError\") {\n          asyncData.status.value = \"idle\";\n          return;\n        }\n        asyncData.error.value = createError(error);\n        asyncData.data.value = unref(options.default());\n        asyncData.status.value = \"error\";\n      }).finally(() => {\n        if (pendingWhenIdle) {\n          asyncData.pending.value = false;\n        }\n        delete nuxtApp._asyncDataPromises[key];\n      });\n      nuxtApp._asyncDataPromises[key] = promise;\n      return nuxtApp._asyncDataPromises[key];\n    },\n    _execute: debounce((...args) => asyncData.execute(...args), 0, { leading: true }),\n    _default: options.default,\n    _deps: 0,\n    _init: true,\n    _hash: import.meta.dev ? createHash(_handler, options) : void 0,\n    _off: () => {\n      unsubRefreshAsyncData();\n      if (nuxtApp._asyncData[key]?._init) {\n        nuxtApp._asyncData[key]._init = false;\n      }\n      if (purgeCachedData && !hasCustomGetCachedData) {\n        nextTick(() => {\n          if (!nuxtApp._asyncData[key]?._init) {\n            clearNuxtDataByKey(nuxtApp, key);\n            asyncData.execute = () => Promise.resolve();\n            asyncData.data.value = asyncDataDefaults.value;\n          }\n        });\n      }\n    }\n  };\n  return asyncData;\n}\nconst getDefault = () => asyncDataDefaults.value;\nconst getDefaultCachedData = (key, nuxtApp, ctx) => {\n  if (nuxtApp.isHydrating) {\n    return nuxtApp.payload.data[key];\n  }\n  if (ctx.cause !== \"refresh:manual\" && ctx.cause !== \"refresh:hook\") {\n    return nuxtApp.static.data[key];\n  }\n};\nfunction createHash(_handler, options) {\n  return {\n    handler: hash(_handler),\n    transform: options.transform ? hash(options.transform) : void 0,\n    pick: options.pick ? hash(options.pick) : void 0,\n    getCachedData: options.getCachedData ? hash(options.getCachedData) : void 0\n  };\n}\nfunction mergeAbortSignals(signals, timeout) {\n  const list = signals.filter((s) => !!s);\n  if (typeof timeout === \"number\" && timeout >= 0) {\n    const timeoutSignal = AbortSignal.timeout?.(timeout);\n    if (timeoutSignal) {\n      list.push(timeoutSignal);\n    }\n  }\n  if (AbortSignal.any) {\n    return AbortSignal.any(list);\n  }\n  const controller = new AbortController();\n  for (const sig of list) {\n    if (sig.aborted) {\n      const reason = sig.reason ?? new DOMException(\"Aborted\", \"AbortError\");\n      try {\n        controller.abort(reason);\n      } catch {\n        controller.abort();\n      }\n      return controller.signal;\n    }\n  }\n  const onAbort = () => {\n    const abortedSignal = list.find((s) => s.aborted);\n    const reason = abortedSignal?.reason ?? new DOMException(\"Aborted\", \"AbortError\");\n    try {\n      controller.abort(reason);\n    } catch {\n      controller.abort();\n    }\n  };\n  for (const sig of list) {\n    sig.addEventListener?.(\"abort\", onAbort, { once: true });\n  }\n  return controller.signal;\n}\n","import { Icon as Iconify, addIcon } from \"@iconify/vue\";\nimport { h } from \"vue\";\nimport { initClientBundle, loadIcon, useResolvedName, resolveCustomizeFn } from \"./shared.js\";\nimport { useAsyncData, useNuxtApp, defineComponent, useAppConfig, onServerPrefetch } from \"#imports\";\nexport const NuxtIconSvg = /* @__PURE__ */ defineComponent({\n  name: \"NuxtIconSvg\",\n  props: {\n    name: {\n      type: String,\n      required: true\n    },\n    customize: {\n      type: [Function, Boolean, null],\n      default: null,\n      required: false\n    }\n  },\n  setup(props, { slots }) {\n    const nuxt = useNuxtApp();\n    const options = useAppConfig().icon;\n    const name = useResolvedName(() => props.name);\n    const storeKey = \"i-\" + name.value;\n    if (name.value) {\n      onServerPrefetch(async () => {\n        if (import.meta.server) {\n          await useAsyncData(\n            storeKey,\n            async () => await loadIcon(name.value, options.fetchTimeout),\n            { deep: false }\n          );\n        }\n      });\n      if (import.meta.client) {\n        const payload = nuxt.payload.data[storeKey];\n        if (payload) {\n          addIcon(name.value, payload);\n        } else {\n          initClientBundle(addIcon);\n        }\n      }\n    }\n    return () => h(Iconify, {\n      icon: name.value,\n      ssr: true,\n      // Iconify uses `customise`, where we expose `customize` for consistency\n      customise: resolveCustomizeFn(props.customize, options.customize)\n    }, slots);\n  }\n});\n","import { computed, defineComponent, h } from \"vue\";\nimport { NuxtIconCss } from \"./css.js\";\nimport { NuxtIconSvg } from \"./svg.js\";\nimport { useResolvedName } from \"./shared.js\";\nimport { useAppConfig, useNuxtApp } from \"#imports\";\nexport default defineComponent({\n  name: \"NuxtIcon\",\n  props: {\n    name: {\n      type: String,\n      required: true\n    },\n    mode: {\n      type: String,\n      required: false,\n      default: null\n    },\n    size: {\n      type: [Number, String],\n      required: false,\n      default: null\n    },\n    customize: {\n      type: [Function, Boolean, null],\n      default: null,\n      required: false\n    }\n  },\n  setup(props, { slots }) {\n    const nuxtApp = useNuxtApp();\n    const runtimeOptions = useAppConfig().icon;\n    const name = useResolvedName(() => props.name);\n    const component = computed(\n      () => nuxtApp.vueApp?.component(name.value) || ((props.mode || runtimeOptions.mode) === \"svg\" ? NuxtIconSvg : NuxtIconCss)\n    );\n    const style = computed(() => {\n      const size = props.size || runtimeOptions.size;\n      return size ? { fontSize: Number.isNaN(+size) ? size : size + \"px\" } : null;\n    });\n    return () => h(\n      component.value,\n      {\n        ...runtimeOptions.attrs,\n        name: name.value,\n        class: runtimeOptions.class,\n        style: style.value,\n        customize: props.customize\n      },\n      slots\n    );\n  }\n});\n"],"version":3}